#!/usr/bin/python3

import os
import sys
from datetime import datetime
from random import randint
from time import sleep

from OpenSSL import SSL

from PyQt5 import uic
from PyQt5.QtCore import Qt, QObject, QUrl, QPoint, QProcess, QSettings, QThread, QTimer, pyqtSignal
from PyQt5.QtWebEngineWidgets import QWebEngineView
from PyQt5.QtWidgets import QWidget, QApplication, QMainWindow, QLineEdit, \
    QSizePolicy, QActionGroup, QMenu, QDialog, QDesktopWidget

from parser_html import appstore
from strategies import _apt

class InstallerThread(QThread):

    transactionCompleted = pyqtSignal(str)

    def __init__(self):
        QThread.__init__(self)

    def run(self):
        current_task = appstore.tasks.pop(0)
        appstore.current_task_details = current_task['details']
        transaction = current_task['transaction']
        # Check if the transaction is a aptdaemon transaction...
        if current_task['details']['pkg_type'] == 'apt':
            # This is not a PyQt signals and slots!
            transaction.connect('progress-changed', self.setProgress)
            transaction.connect('finished', self.transactionFinished)
            transaction.run()

        elif current_task['details']['pkg_type'] == 'flatpak':
            pass  # TODO

    def setProgress(self, trans, progress):
        window.webEngine.page().runJavaScript('setProgress(%s)' % progress)

    def transactionFinished(self, trans, exit_status):
        print(exit_status)
        self.transactionCompleted.emit(exit_status)
        #window.webEngine.reload()

class WebUiThread(QThread):
    def __init__(self):
        QThread.__init__(self)
        self.port_found = False
        self.server = '0.0.0.0'
        self.port = 5000
        self.start()

        print(self.currentThread())

        #self.context = SSL.Context(SSL.PROTOCOL_TLSv1)
        #self.context.use_privatekey_file('server.key')
        #self.context.use_certificate_file('server.crt')

    def run(self):
        while True:
            try:
                appstore.app.run(host='0.0.0.0', port=self.port)
                self.port_found = True
            except OSError:
                self.port = self.port + randint(1, 10)
                continue
            break

    # We need this sleep time otherwise initial value (default) of self.port is
    # passed to the main thread. This results in QWebEngine loading URL with
    # wrong port. The number 0.12 is completely arbitrary, fast enough for
    # humans to see, slow enough for machine to process.

    def getPort(self):
        sleep(0.12)
        return self.port


class MainWindow(QMainWindow):
    def __init__(self):
        super(MainWindow, self).__init__()

        self.apt = _apt.QAptInterface()

        self.api_service = 'https://superxos.com'

        self.daemon = WebUiThread()

        self.installer = InstallerThread()

        self.timer = QTimer()
        self.timer.timeout.connect(self.timeOut)
        self.timer.start(5000)

        # Reconnect the timer.
        self.installer.transactionCompleted.connect(
            lambda: self.timer.timeout.connect(self.timeOut))


        self.server = 'http://{}:{}/'.format(self.daemon.server,
                                             self.daemon.getPort())

        self = uic.loadUi('window.ui', self)

        self.settings = QSettings('superx-storerc')
        self.search_name = self.settings.value('search_name', type=bool)
        self.search_summery = self.settings.value('search_summery', type=bool)
        self.search_desc = self.settings.value('search_desc', type=bool)

        if self.search_name:
            self.actionSearchName.setChecked(True)
        if self.search_summery:
            self.actionSearchSummery.setChecked(True)
        if self.search_desc:
            self.actionSearchDescription.setChecked(True)

        toolbarGroup = QActionGroup(self.toolBar)
        toolbarGroup.addAction(self.actionHome)
        toolbarGroup.addAction(self.actionCategories)
        toolbarGroup.addAction(self.actionLibrary)
        toolbarGroup.addAction(self.actionUpdates)
        toolbarGroup.addAction(self.actionTasks)
        toolbarGroup.addAction(self.actionExplorer)
        toolbarGroup.addAction(self.actionApp)
        toolbarGroup.addAction(self.actionSearch)
        toolbarGroup.addAction(self.actionPurchases)
        toolbarGroup.setExclusive(True)

        # Only show explorer when user goes to dynamic pages.
        self.actionExplorer.setVisible(False)

        # TODO: Implement app purchase and display
        purchased_apps = False
        if purchased_apps:
            self.actionPurchases.setVisible(True)
        else:
            self.actionPurchases.setVisible(False)

        # Only show updates when software updates are available.
        updates_available = False
        if updates_available:
            self.actionUpdates.setVisible(True)
        else:
            self.actionUpdates.setVisible(False)

        # Only show tasks when some tasks are running.
        # TODO: self.actionTasks.setIcon(QIcon(QMovie)) once system is ready.
        self.actionTasks.setVisible(False)

        self.searchBar = QLineEdit()
        self.searchBar.setPlaceholderText('Search...')
        self.searchBar.setFocusPolicy(Qt.StrongFocus)

        spacer = QWidget()
        spacer.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
        self.toolBar.addWidget(spacer)
        self.toolBar.addWidget(self.searchBar)
        self.toolBar.addAction(self.actionConfigure)
        self.toolBar.setContextMenuPolicy(Qt.CustomContextMenu)

        self.webEngine = QWebEngineView()
        self.centralwidget.layout().addWidget(self.webEngine)

        # Signals and slots
        self.actionBack.triggered.connect(self.webEngine.back)
        self.actionForward.triggered.connect(self.webEngine.forward)
        self.actionForward.triggered.connect(self.urlProcess)
        self.actionConfigure.triggered.connect(self.configMenu)

        self.actionSoftwareSources.triggered.connect(self.editSources)
        self.actionAbout.triggered.connect(self.aboutDialog)

        self.actionHome.triggered.connect(lambda: self.webEngine.load(
            QUrl(self.server)))
        self.actionCategories.triggered.connect(lambda: self.webEngine.load(
            QUrl(os.path.join(self.server, 'categories'))))
        self.actionLibrary.triggered.connect(lambda: self.webEngine.load(
            QUrl(os.path.join(self.server, 'library'))))
        self.actionUpdates.triggered.connect(lambda: self.webEngine.load(
            QUrl(os.path.join(self.server, 'updates'))))
        self.actionTasks.triggered.connect(lambda: self.webEngine.load(
            QUrl(os.path.join(self.server, 'tasks'))))

        self.searchBar.returnPressed.connect(self.searchQuery)

        self.webEngine.urlChanged.connect(self.urlProcess)

        self.actionSearchName.toggled.connect(self.settingsWrite)
        self.actionSearchSummery.toggled.connect(self.settingsWrite)
        self.actionSearchDescription.toggled.connect(self.settingsWrite)

        screen = QDesktopWidget().screenGeometry()
        window = self.geometry()
        hposition = (screen.width() - window.width()) / 2
        vposition = (screen.height() - window.height()) / 2
        self.move(hposition, vposition)

        self.webEngine.load(QUrl(self.server))

        self.show()
        self.searchBar.setFocus()

    def timeOut(self):
        print(appstore.tasks)
        if not self.installer.isRunning() and len(appstore.tasks) != 0:
            self.timer.timeout.disconnect()
            self.installer.start()

    def searchQuery(self):
        search_parms = (
        self.searchBar.text(), self.search_name, self.search_summery,
        self.search_desc)
        self.webEngine.load(QUrl(os.path.join(
            self.server,
            'search?q=%s&search_name=%s&search_summery=%s&search_desc=%s' %
            search_parms)))
        print(self.webEngine.url())

    def settingsWrite(self):
        if self.actionSearchName.isChecked():
            self.settings.setValue('search_name', True)
            self.search_name = True
        else:
            self.settings.setValue('search_name', False)
            self.search_name = False

        if self.actionSearchSummery.isChecked():
            self.settings.setValue('search_summery', True)
            self.search_summery = True
        else:
            self.settings.setValue('search_summery', False)
            self.search_summery = False

        if self.actionSearchDescription.isChecked():
            self.settings.setValue('search_desc', True)
            self.search_desc = True
        else:
            self.settings.setValue('search_desc', False)
            self.search_desc = False

    def processTasks(self, url):
        print(url)
        pkg_id = url.split('?id=')[1].split('&p_type=')
        transaction = None
        task_details = appstore.backend_obj.appSummery(pkg_id[0])
        task_details['pkg_type'] = pkg_id[1]

        if '/install/' in url:
            task_details['action'] = 'Installing'
        elif '/remove/' in url:
            task_details['action'] = 'Removing'

        if task_details['pkg_type'] == 'apt':
            if task_details['action'] == 'Installing':
                transaction = self.apt.aptd.install_packages(
                    task_details['pkg'])
            elif task_details['action'] == 'Removing':
                transaction = self.apt.aptd.remove_packages(
                    task_details['pkg'])

        elif task_details['pkg_type'] == 'flatpak':
            pass # TODO

        task = {'details': task_details, 'transaction': transaction}

        appstore.tasks.append(task)


    def urlProcess(self):
        self.searchBar.clear()
        url = self.webEngine.url().toString()
   
        self.actionExplorer.setVisible(False)
        self.actionExplorer.setChecked(False)
        self.actionApp.setVisible(False)
        self.actionSearch.setVisible(False)

        if url == self.server:
            self.actionHome.setChecked(True)
        elif url.startswith('%scategories' % self.server):
            self.actionCategories.setChecked(True)
        elif url.startswith('%slibrary' % self.server):
            self.actionLibrary.setChecked(True)
        elif url.startswith('%supdates' % self.server):
            self.actionUpdates.setChecked(True)
        elif url.startswith('%stasks' % self.server):
            self.actionTasks.setChecked(True)
        elif url.startswith('%sdetails' % self.server):
            self.actionApp.setVisible(True)
            self.actionApp.setChecked(True)
        elif url.startswith('%ssearch' % self.server):
            self.actionSearch.setVisible(True)
            self.actionSearch.setChecked(True)
        elif url.startswith('%suploadScreenshot' % self.server):
            url = url.split(self.server)[1]
            browser = QProcess()
            browser.startDetached('xdg-open %s/%s ' % (self.api_service, url))
        elif url.startswith('%sinstall' % self.server) or \
                url.startswith('%sremove' % self.server):
            self.processTasks(url)
        else:
            self.actionExplorer.setVisible(True)
            self.actionExplorer.setChecked(True)

    def aboutDialog(self):
        dialog = QDialog(parent=window)
        dialog.ui = uic.loadUi('about.ui')
        copyright = 'Copyright (c) %s Libresoft Technology Pvt. Ltd.' \
                    % datetime.now().year
        dialog.ui.label_2.setText(copyright)
        dialog.setAttribute(Qt.WA_DeleteOnClose)
        dialog.ui.show()

    def editSources(self):
        superx_sources = QProcess()
        superx_sources.startDetached('superx-sources')

    def configMenu(self):
        configMenu = QMenu(parent=window)
        configMenu.addAction(self.actionSearchName)
        configMenu.addAction(self.actionSearchSummery)
        configMenu.addAction(self.actionSearchDescription)
        configMenu.addAction(self.actionSoftwareSources)
        configMenu.addAction(self.actionAbout)
        # Check for a better menu system.
        point = QPoint(self.searchBar.frameGeometry().x() +
                       self.searchBar.frameGeometry().width() - 309, 30)
        configMenu.popup(QWidget.mapToGlobal(self, point))


if __name__ == '__main__':
    app = QApplication(sys.argv)
    app.setAttribute(Qt.AA_UseSoftwareOpenGL)
    window = MainWindow()
    sys.exit(app.exec_())
